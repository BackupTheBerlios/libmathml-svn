#include "attributes.h"
using namespace MML;
// this file was automatically generated by 'parseschema'
const MMLAttribute *Attributes::defatt[numAttributes];
const bool &
Attributes::accent() const {
	return static_cast<const MMLbool*>(att[0])->value;
}
const bool &
Attributes::accentunder() const {
	return static_cast<const MMLbool*>(att[1])->value;
}
const DOMString &
Attributes::actiontype() const {
	return static_cast<const MMLDOMString*>(att[2])->value;
}
const DOMString &
Attributes::align() const {
	return static_cast<const MMLDOMString*>(att[3])->value;
}
const DOMString &
Attributes::alignmentscope() const {
	return static_cast<const MMLDOMString*>(att[4])->value;
}
const DOMString &
Attributes::alt() const {
	return static_cast<const MMLDOMString*>(att[5])->value;
}
const DOMString &
Attributes::altimg() const {
	return static_cast<const MMLDOMString*>(att[6])->value;
}
const DOMString &
Attributes::alttext() const {
	return static_cast<const MMLDOMString*>(att[7])->value;
}
const MathColor &
Attributes::background() const {
	return static_cast<const MMLMathColor*>(att[8])->value;
}
const int &
Attributes::base() const {
	return static_cast<const MMLint*>(att[9])->value;
}
const DOMString &
Attributes::baseline() const {
	return static_cast<const MMLDOMString*>(att[10])->value;
}
const bool &
Attributes::bevelled() const {
	return static_cast<const MMLbool*>(att[11])->value;
}
const DOMString &
Attributes::class_() const {
	return static_cast<const MMLDOMString*>(att[12])->value;
}
const DOMString &
Attributes::close() const {
	return static_cast<const MMLDOMString*>(att[13])->value;
}
const closure::Closure &
Attributes::closure() const {
	return static_cast<const MMLClosure*>(att[14])->value;
}
const MathColor &
Attributes::color() const {
	return static_cast<const MMLMathColor*>(att[15])->value;
}
const DOMString &
Attributes::columnalign() const {
	return static_cast<const MMLDOMString*>(att[16])->value;
}
const DOMString &
Attributes::columnlines() const {
	return static_cast<const MMLDOMString*>(att[17])->value;
}
const DOMString &
Attributes::columnspacing() const {
	return static_cast<const MMLDOMString*>(att[18])->value;
}
const int &
Attributes::columnspan() const {
	return static_cast<const MMLint*>(att[19])->value;
}
const DOMString &
Attributes::columnwidth() const {
	return static_cast<const MMLDOMString*>(att[20])->value;
}
const DOMString &
Attributes::definitionURL() const {
	return static_cast<const MMLDOMString*>(att[21])->value;
}
const DOMString &
Attributes::denomalign() const {
	return static_cast<const MMLDOMString*>(att[22])->value;
}
const h_unit &
Attributes::depth() const {
	return static_cast<const MMLh_unit*>(att[23])->value;
}
const display::Display &
Attributes::display() const {
	return static_cast<const MMLDisplay*>(att[24])->value;
}
const bool &
Attributes::displaystyle() const {
	return static_cast<const MMLbool*>(att[25])->value;
}
const edge::Edge &
Attributes::edge() const {
	return static_cast<const MMLEdge*>(att[26])->value;
}
const DOMString &
Attributes::encoding() const {
	return static_cast<const MMLDOMString*>(att[27])->value;
}
const bool &
Attributes::equalcolumns() const {
	return static_cast<const MMLbool*>(att[28])->value;
}
const bool &
Attributes::equalrows() const {
	return static_cast<const MMLbool*>(att[29])->value;
}
const bool &
Attributes::fence() const {
	return static_cast<const MMLbool*>(att[30])->value;
}
const DOMString &
Attributes::fontfamily() const {
	return static_cast<const MMLDOMString*>(att[31])->value;
}
const form::Form &
Attributes::form() const {
	return static_cast<const MMLForm*>(att[32])->value;
}
const frame::Frame &
Attributes::frame() const {
	return static_cast<const MMLFrame*>(att[33])->value;
}
const DOMString &
Attributes::framespacing() const {
	return static_cast<const MMLDOMString*>(att[34])->value;
}
const groupalign::Groupalign &
Attributes::groupalign() const {
	return static_cast<const MMLGroupalign*>(att[35])->value;
}
const v_unit &
Attributes::height() const {
	return static_cast<const MMLv_unit*>(att[36])->value;
}
const DOMString &
Attributes::id() const {
	return static_cast<const MMLDOMString*>(att[37])->value;
}
const int &
Attributes::index() const {
	return static_cast<const MMLint*>(att[38])->value;
}
const bool &
Attributes::largeop() const {
	return static_cast<const MMLbool*>(att[39])->value;
}
const linebreak::Linebreak &
Attributes::linebreak() const {
	return static_cast<const MMLLinebreak*>(att[40])->value;
}
const v_unit &
Attributes::linethickness() const {
	return static_cast<const MMLv_unit*>(att[41])->value;
}
const DOMString &
Attributes::lquote() const {
	return static_cast<const MMLDOMString*>(att[42])->value;
}
const h_unit &
Attributes::lspace() const {
	return static_cast<const MMLh_unit*>(att[43])->value;
}
const DOMString &
Attributes::macros() const {
	return static_cast<const MMLDOMString*>(att[44])->value;
}
const MathColor &
Attributes::mathbackground() const {
	return static_cast<const MMLMathColor*>(att[45])->value;
}
const MathColor &
Attributes::mathcolor() const {
	return static_cast<const MMLMathColor*>(att[46])->value;
}
const v_unit &
Attributes::mathsize() const {
	return static_cast<const MMLv_unit*>(att[47])->value;
}
const mathvariant::Mathvariant &
Attributes::mathvariant() const {
	return static_cast<const MMLMathvariant*>(att[48])->value;
}
const h_unit &
Attributes::maxsize() const {
	return static_cast<const MMLh_unit*>(att[49])->value;
}
const h_unit &
Attributes::mediummathspace() const {
	return static_cast<const MMLh_unit*>(att[50])->value;
}
const h_unit &
Attributes::minlabelspacing() const {
	return static_cast<const MMLh_unit*>(att[51])->value;
}
const h_unit &
Attributes::minsize() const {
	return static_cast<const MMLh_unit*>(att[52])->value;
}
const bool &
Attributes::movablelimits() const {
	return static_cast<const MMLbool*>(att[53])->value;
}
const DOMString &
Attributes::name() const {
	return static_cast<const MMLDOMString*>(att[54])->value;
}
const int &
Attributes::nargs() const {
	return static_cast<const MMLint*>(att[55])->value;
}
const notation::Notation &
Attributes::notation() const {
	return static_cast<const MMLNotation*>(att[56])->value;
}
const DOMString &
Attributes::numalign() const {
	return static_cast<const MMLDOMString*>(att[57])->value;
}
const occurrence::Occurrence &
Attributes::occurrence() const {
	return static_cast<const MMLOccurrence*>(att[58])->value;
}
const DOMString &
Attributes::open() const {
	return static_cast<const MMLDOMString*>(att[59])->value;
}
const order::Order &
Attributes::order() const {
	return static_cast<const MMLOrder*>(att[60])->value;
}
const overflow::Overflow &
Attributes::overflow() const {
	return static_cast<const MMLOverflow*>(att[61])->value;
}
const DOMString &
Attributes::rowalign() const {
	return static_cast<const MMLDOMString*>(att[62])->value;
}
const DOMString &
Attributes::rowlines() const {
	return static_cast<const MMLDOMString*>(att[63])->value;
}
const DOMString &
Attributes::rowspacing() const {
	return static_cast<const MMLDOMString*>(att[64])->value;
}
const int &
Attributes::rowspan() const {
	return static_cast<const MMLint*>(att[65])->value;
}
const DOMString &
Attributes::rquote() const {
	return static_cast<const MMLDOMString*>(att[66])->value;
}
const h_unit &
Attributes::rspace() const {
	return static_cast<const MMLh_unit*>(att[67])->value;
}
const DOMString &
Attributes::scope() const {
	return static_cast<const MMLDOMString*>(att[68])->value;
}
const int &
Attributes::scriptlevel() const {
	return static_cast<const MMLint*>(att[69])->value;
}
const v_unit &
Attributes::scriptminsize() const {
	return static_cast<const MMLv_unit*>(att[70])->value;
}
const float &
Attributes::scriptsizemultiplier() const {
	return static_cast<const MMLfloat*>(att[71])->value;
}
const int &
Attributes::selection() const {
	return static_cast<const MMLint*>(att[72])->value;
}
const bool &
Attributes::separator() const {
	return static_cast<const MMLbool*>(att[73])->value;
}
const DOMString &
Attributes::separators() const {
	return static_cast<const MMLDOMString*>(att[74])->value;
}
const side::Side &
Attributes::side() const {
	return static_cast<const MMLSide*>(att[75])->value;
}
const bool &
Attributes::stretchy() const {
	return static_cast<const MMLbool*>(att[76])->value;
}
const DOMString &
Attributes::style() const {
	return static_cast<const MMLDOMString*>(att[77])->value;
}
const h_unit &
Attributes::subscriptshift() const {
	return static_cast<const MMLh_unit*>(att[78])->value;
}
const h_unit &
Attributes::superscriptshift() const {
	return static_cast<const MMLh_unit*>(att[79])->value;
}
const bool &
Attributes::symmetric() const {
	return static_cast<const MMLbool*>(att[80])->value;
}
const h_unit &
Attributes::thickmathspace() const {
	return static_cast<const MMLh_unit*>(att[81])->value;
}
const h_unit &
Attributes::thinmathspace() const {
	return static_cast<const MMLh_unit*>(att[82])->value;
}
const DOMString &
Attributes::type() const {
	return static_cast<const MMLDOMString*>(att[83])->value;
}
const h_unit &
Attributes::verythickmathspace() const {
	return static_cast<const MMLh_unit*>(att[84])->value;
}
const h_unit &
Attributes::verythinmathspace() const {
	return static_cast<const MMLh_unit*>(att[85])->value;
}
const h_unit &
Attributes::veryverythickmathspace() const {
	return static_cast<const MMLh_unit*>(att[86])->value;
}
const h_unit &
Attributes::veryverythinmathspace() const {
	return static_cast<const MMLh_unit*>(att[87])->value;
}
const h_unit &
Attributes::width() const {
	return static_cast<const MMLh_unit*>(att[88])->value;
}
const DOMString &
Attributes::xlink_href() const {
	return static_cast<const MMLDOMString*>(att[89])->value;
}
const DOMString &
Attributes::xref() const {
	return static_cast<const MMLDOMString*>(att[90])->value;
}
#include <iostream>
using std::endl;
using std::cerr;
void
Attributes::setAttribute(MML::Attribute a, const DOMString &value) {
	const MMLAttribute *newA;
	if (attTypes[a] != DOMSTRING_T) {
		AttributeType type = attTypes[a];
		newA = attFunc[type](value, a);
		if (!newA) {
			cerr << "error in creating attribute  '"<<attributeTag[a]<<"' with value '" << value.utf8() << "'" << endl;
		}
	} else {
		newA = new MMLDOMString(value);
	}
	cur->add(a, newA, att[a]);
	att[a] = newA;
	if (ps) ps->set(a);
}

void
Attributes::setAttribute(MML::Attribute a, const MathColor &value) {
	const MMLAttribute *newA;
	if (attTypes[a] != MATHCOLOR_T) {
		cerr << "Attribute " << attributeTag[a]
			<< " is not of type MathColor." << endl;
		exit(1);
	} else {
		newA = new MMLMathColor(value);
	}
	cur->add(a, newA, att[a]);
	att[a] = newA;
	if (ps) ps->set(a);
}

void
Attributes::setAttribute(MML::Attribute a, const bool &value) {
	const MMLAttribute *newA;
	if (attTypes[a] != BOOL_T) {
		cerr << "Attribute " << attributeTag[a]
			<< " is not of type bool." << endl;
		exit(1);
	} else {
		newA = new MMLbool(value);
	}
	cur->add(a, newA, att[a]);
	att[a] = newA;
	if (ps) ps->set(a);
}

void
Attributes::setAttribute(MML::Attribute a, const closure::Closure &value) {
	const MMLAttribute *newA;
	if (attTypes[a] != CLOSURE_T) {
		cerr << "Attribute " << attributeTag[a]
			<< " is not of type closure::Closure." << endl;
		exit(1);
	} else {
		newA = new MMLClosure(value);
	}
	cur->add(a, newA, att[a]);
	att[a] = newA;
	if (ps) ps->set(a);
}

void
Attributes::setAttribute(MML::Attribute a, const display::Display &value) {
	const MMLAttribute *newA;
	if (attTypes[a] != DISPLAY_T) {
		cerr << "Attribute " << attributeTag[a]
			<< " is not of type display::Display." << endl;
		exit(1);
	} else {
		newA = new MMLDisplay(value);
	}
	cur->add(a, newA, att[a]);
	att[a] = newA;
	if (ps) ps->set(a);
}

void
Attributes::setAttribute(MML::Attribute a, const edge::Edge &value) {
	const MMLAttribute *newA;
	if (attTypes[a] != EDGE_T) {
		cerr << "Attribute " << attributeTag[a]
			<< " is not of type edge::Edge." << endl;
		exit(1);
	} else {
		newA = new MMLEdge(value);
	}
	cur->add(a, newA, att[a]);
	att[a] = newA;
	if (ps) ps->set(a);
}

void
Attributes::setAttribute(MML::Attribute a, const float &value) {
	const MMLAttribute *newA;
	if (attTypes[a] != FLOAT_T) {
		cerr << "Attribute " << attributeTag[a]
			<< " is not of type float." << endl;
		exit(1);
	} else {
		newA = new MMLfloat(value);
	}
	cur->add(a, newA, att[a]);
	att[a] = newA;
	if (ps) ps->set(a);
}

void
Attributes::setAttribute(MML::Attribute a, const form::Form &value) {
	const MMLAttribute *newA;
	if (attTypes[a] != FORM_T) {
		cerr << "Attribute " << attributeTag[a]
			<< " is not of type form::Form." << endl;
		exit(1);
	} else {
		newA = new MMLForm(value);
	}
	cur->add(a, newA, att[a]);
	att[a] = newA;
	if (ps) ps->set(a);
}

void
Attributes::setAttribute(MML::Attribute a, const frame::Frame &value) {
	const MMLAttribute *newA;
	if (attTypes[a] != FRAME_T) {
		cerr << "Attribute " << attributeTag[a]
			<< " is not of type frame::Frame." << endl;
		exit(1);
	} else {
		newA = new MMLFrame(value);
	}
	cur->add(a, newA, att[a]);
	att[a] = newA;
	if (ps) ps->set(a);
}

void
Attributes::setAttribute(MML::Attribute a, const groupalign::Groupalign &value) {
	const MMLAttribute *newA;
	if (attTypes[a] != GROUPALIGN_T) {
		cerr << "Attribute " << attributeTag[a]
			<< " is not of type groupalign::Groupalign." << endl;
		exit(1);
	} else {
		newA = new MMLGroupalign(value);
	}
	cur->add(a, newA, att[a]);
	att[a] = newA;
	if (ps) ps->set(a);
}

void
Attributes::setAttribute(MML::Attribute a, const h_unit &value) {
	const MMLAttribute *newA;
	if (attTypes[a] != H_UNIT_T) {
		cerr << "Attribute " << attributeTag[a]
			<< " is not of type h_unit." << endl;
		exit(1);
	} else {
		newA = new MMLh_unit(value);
	}
	cur->add(a, newA, att[a]);
	att[a] = newA;
	if (ps) ps->set(a);
}

void
Attributes::setAttribute(MML::Attribute a, const int &value) {
	const MMLAttribute *newA;
	if (attTypes[a] != INT_T) {
		cerr << "Attribute " << attributeTag[a]
			<< " is not of type int." << endl;
		exit(1);
	} else {
		newA = new MMLint(value);
	}
	cur->add(a, newA, att[a]);
	att[a] = newA;
	if (ps) ps->set(a);
}

void
Attributes::setAttribute(MML::Attribute a, const linebreak::Linebreak &value) {
	const MMLAttribute *newA;
	if (attTypes[a] != LINEBREAK_T) {
		cerr << "Attribute " << attributeTag[a]
			<< " is not of type linebreak::Linebreak." << endl;
		exit(1);
	} else {
		newA = new MMLLinebreak(value);
	}
	cur->add(a, newA, att[a]);
	att[a] = newA;
	if (ps) ps->set(a);
}

void
Attributes::setAttribute(MML::Attribute a, const mathvariant::Mathvariant &value) {
	const MMLAttribute *newA;
	if (attTypes[a] != MATHVARIANT_T) {
		cerr << "Attribute " << attributeTag[a]
			<< " is not of type mathvariant::Mathvariant." << endl;
		exit(1);
	} else {
		newA = new MMLMathvariant(value);
	}
	cur->add(a, newA, att[a]);
	att[a] = newA;
	if (ps) ps->set(a);
}

void
Attributes::setAttribute(MML::Attribute a, const notation::Notation &value) {
	const MMLAttribute *newA;
	if (attTypes[a] != NOTATION_T) {
		cerr << "Attribute " << attributeTag[a]
			<< " is not of type notation::Notation." << endl;
		exit(1);
	} else {
		newA = new MMLNotation(value);
	}
	cur->add(a, newA, att[a]);
	att[a] = newA;
	if (ps) ps->set(a);
}

void
Attributes::setAttribute(MML::Attribute a, const occurrence::Occurrence &value) {
	const MMLAttribute *newA;
	if (attTypes[a] != OCCURRENCE_T) {
		cerr << "Attribute " << attributeTag[a]
			<< " is not of type occurrence::Occurrence." << endl;
		exit(1);
	} else {
		newA = new MMLOccurrence(value);
	}
	cur->add(a, newA, att[a]);
	att[a] = newA;
	if (ps) ps->set(a);
}

void
Attributes::setAttribute(MML::Attribute a, const order::Order &value) {
	const MMLAttribute *newA;
	if (attTypes[a] != ORDER_T) {
		cerr << "Attribute " << attributeTag[a]
			<< " is not of type order::Order." << endl;
		exit(1);
	} else {
		newA = new MMLOrder(value);
	}
	cur->add(a, newA, att[a]);
	att[a] = newA;
	if (ps) ps->set(a);
}

void
Attributes::setAttribute(MML::Attribute a, const overflow::Overflow &value) {
	const MMLAttribute *newA;
	if (attTypes[a] != OVERFLOW_T) {
		cerr << "Attribute " << attributeTag[a]
			<< " is not of type overflow::Overflow." << endl;
		exit(1);
	} else {
		newA = new MMLOverflow(value);
	}
	cur->add(a, newA, att[a]);
	att[a] = newA;
	if (ps) ps->set(a);
}

void
Attributes::setAttribute(MML::Attribute a, const side::Side &value) {
	const MMLAttribute *newA;
	if (attTypes[a] != SIDE_T) {
		cerr << "Attribute " << attributeTag[a]
			<< " is not of type side::Side." << endl;
		exit(1);
	} else {
		newA = new MMLSide(value);
	}
	cur->add(a, newA, att[a]);
	att[a] = newA;
	if (ps) ps->set(a);
}

void
Attributes::setAttribute(MML::Attribute a, const v_unit &value) {
	const MMLAttribute *newA;
	if (attTypes[a] != V_UNIT_T) {
		cerr << "Attribute " << attributeTag[a]
			<< " is not of type v_unit." << endl;
		exit(1);
	} else {
		newA = new MMLv_unit(value);
	}
	cur->add(a, newA, att[a]);
	att[a] = newA;
	if (ps) ps->set(a);
}

